pub require "expression/literal"
require "mod:thomasvergne/plume-combinator"

type Expression {
  Variable(str),
  Literal(Literal),
  Application(Expression, list<Expression>),
  Lambda(list<str>, Expression),
  Locate(Expression, (Location, Location))
}

type Toplevel {
  Expression(Expression),
  Definition(str, Expression)
}

extend show<Expression> {
  fn show_prec(x, _) => switch x {
    case Variable(name) => name
    case Literal(lit) => show(lit)
    case Application(f, args) => show(f) + "(" + join_str(args.map(show), ", ") + ")"
    case Lambda(params, body) => "fn(" + join_str(params, ", ") + ") => " + show(body)
    case Locate(expr, loc) => "$expr at $loc"
    case ? => "Unknown"
  }
}

extend show<Toplevel> {
  fn show_prec(x, _) => switch x {
    case Expression(expr) => show(expr)
    case Definition(name, expr) => name + " = " + expr.show()
  }
}

extend equality<Expression> {
  fn (==) (x, y) => switch (x, y) {
    case (Variable(a), Variable(b)) => 
      a == b
    case (Literal(a), Literal(b)) => 
      a == b
    case (Application(f1, args1), Application(f2, args2)) => 
      f1 == f2 and args1 == args2
    case (Lambda(params1, body1), Lambda(params2, body2)) => 
      params1 == params2 and body1 == body2
    case (Locate(expr1, ?), Locate(expr2, ?)) =>
      expr1 == expr2
    case ? => false
  }
}

extend equality<Toplevel> {
  fn (==) (x, y) => switch (x, y) {
    case (Expression(a), Expression(b)) => 
      a == b
    case (Definition(a, b), Definition(c, d)) => 
      a == c and b == d
    case _ => false
  }
}
